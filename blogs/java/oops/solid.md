# 🧱 SOLID Principles

SOLID is an acronym for five object‑oriented design principles introduced by Robert C. Martin to create maintainable, scalable, and robust software systems.

## Principles

| Principle | Description |
|---|---|
| S — Single Responsibility Principle | A class should have only one reason to change. |
| O — Open/Closed Principle | Software entities should be open for extension but closed for modification. |
| L — Liskov Substitution Principle | Subtypes must be substitutable for their base types. |
| I — Interface Segregation Principle | Clients should not be forced to depend on interfaces they do not use. |
| D — Dependency Inversion Principle | High‑level modules should not depend on low‑level modules; both should depend on abstractions. |

## 🎯 Why use SOLID?
SOLID principles help developers:

- ✅ Improve code maintainability and readability  
- 🧩 Promote modular architecture  
- 🔗 Reduce tight coupling between components  
- 🧪 Enhance testability and scalability  
- 🔧 Make systems easier to extend without breaking existing functionality

## ✅ Advantages
- Maintainability — Easier to update and debug code without unintended side effects  
- Scalability — Supports growth and new features with minimal disruption  
- Reusability — Promotes reusable components and services  
- Testability — Encourages writing testable units with clear responsibilities  
- Flexibility — Enables swapping implementations easily using abstractions

## ⚠️ Disadvantages
- Over‑engineering — Rigid application can lead to unnecessary abstractions and boilerplate  
- Learning curve — Requires deeper understanding of design patterns and architecture  
- Reduced performance — Excessive abstraction may impact performance in some cases  
- Slower initial development — More planning and separation of concerns up front

## 🧠 When to use / avoid

| Use When… | Avoid When… |
|---|---|
| Building large, complex, or long‑term systems | Writing quick scripts or prototypes |
| Working in teams with shared codebases | Developing highly performance‑critical modules |
| Designing APIs or reusable libraries | Solving simple problems with minimal logic |

---
